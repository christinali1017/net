#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>


#include <iostream>
#include <queue>
#include "tcpstate.h"
#include "Minet.h"
#include "tcp.h"
#include "sockint.h"
#include "packet_queue.h"
#include "constate.h"

using std::cout;
using std::endl;
using std::cerr;
using std::string;
using std::queue;


/*Questions: 
1) When IS_RST, do we need to close the established connection, and set state to RCVD
2) checksum 
3) send packets need a buffer? 
*/

/* Variable */

/* flag for received packet */
unsigned char oldflags;

/* flag for the packet to be sent*/
unsigned char flags = 0;
unsigned char &flagsr = flags;
unsigned int acknum = 0;
unsigned int &acknumr = acknum;
unsigned int seqnum = 0;
unsigned int &seqnumr = seqnum;
unsigned short winsize = 14600;
unsigned short &winsizer = winsize;
/*urgent pointer*/
unsigned short uptr = 0;
unsigned short &uptrr = uptr;

unsigned int id = rand() % 10000;
unsigned int &idr = id;
unsigned int hlen = 0;
unsigned int &hlenr = hlen;

#define S_SYN_ACK 0
#define S_RST 1
#define S_ACK 2
#define S_FIN 3
#define S_SYN 4

/*functions */

/*Make packet, set address, port, protocol, sequence number, ack number, winsize, etc*/
Packet MakeTCPPacket(const Connection c, const unsigned int &id, const unsigned int &seqnum, const unsigned int &acknum, const unsigned short &winsize, const unsigned char &hlen, const unsigned short &urgptr, const unsigned char &flags, const char *data, const size_t datalen);

/* ? */
int ConditionalMinetSend(const MinetHandle &handle, const Packet &object);

Packet createPacket(ConnectionToStateMapping<TCPState>& constate, const unsigned int &id,const unsigned char &flags, const char *data, const size_t datalen);

int main(int argc, char *argv[])
{
/*This is a handle to a communication channel to another module*/

  /* mux, between transport layer and network layer */
  /* sock, between transport layer and application layer */
  MinetHandle mux, sock;  
  ConnectionList<TCPState> clist;
  MinetInit(MINET_TCP_MODULE);

  /* Initialize random number generator */
  srand(time(NULL));

  /* queue for the pending sockets */
  queue<SockRequestResponse> SocksPending;

  Buffer tdata;
  Buffer &data = tdata;

  /*MinetIsModuleInConfig: This checks to see if the specified module is a part of the run-time config. */
  mux=MinetIsModuleInConfig(MINET_IP_MUX) ? MinetConnect(MINET_IP_MUX) : MINET_NOHANDLE;

  sock=MinetIsModuleInConfig(MINET_SOCK_MODULE) ? MinetAccept(MINET_SOCK_MODULE) : MINET_NOHANDLE;

  if (MinetIsModuleInConfig(MINET_IP_MUX) && mux==MINET_NOHANDLE) {
    MinetSendToMonitor(MinetMonitoringEvent("Can't connect to mux"));
    return -1;
  }

  if (MinetIsModuleInConfig(MINET_SOCK_MODULE) && sock==MINET_NOHANDLE) {
    MinetSendToMonitor(MinetMonitoringEvent("Can't accept from sock module"));
    return -1;
  }

  MinetSendToMonitor(MinetMonitoringEvent("tcp_module handling TCP traffic"));

  MinetEvent event;

  while (MinetGetNextEvent(event)==0) {
    cerr << "Start................"<< endl;
    // if we received an unexpected type of event, print error
    if (event.eventtype!=MinetEvent::Dataflow 
	|| event.direction!=MinetEvent::IN) {
      MinetSendToMonitor(MinetMonitoringEvent("Unknown event ignored."));
    // if we received a valid event from Minet, do processing
    } else {
          //  Data from the IP layer below  //
        if (event.handle==mux) {
          	Packet p;
          	MinetReceive(mux,p);
		
		/* this len have already divide 4 */
          	unsigned tcphlen=TCPHeader::EstimateTCPHeaderLength(p);
          	cerr << "estimated header len="<<tcphlen<<"\n";
          	p.ExtractHeaderFromPayload<TCPHeader>(tcphlen);
          	IPHeader ipl=p.FindHeader(Headers::IPHeader);
          	TCPHeader tcph=p.FindHeader(Headers::TCPHeader);

          	cerr << "TCP Packet: IP Header is "<<ipl<<" and ";
          	cerr << "TCP Header is "<<tcph << " and ";

          	cerr << "Checksum is " << (tcph.IsCorrectChecksum(p) ? "VALID" : "INVALID");
          	
            /*Get port and addresses*/
            Connection c;
            ipl.GetSourceIP(c.dest);
            ipl.GetDestIP(c.src);
            tcph.GetDestPort(c.srcport);
            tcph.GetSourcePort(c.destport);
            c.protocol = IP_PROTO_TCP;

            /*Get parameters*/
 //           tcph.GetFlags(oldflags);
   //         tcph.GetSeqNum(acknumr);
   //         tcph.GetAckNum(seqnumr);


            ConnectionList<TCPState>::iterator cs = clist.FindMatching(c);

            /* if clist is empty*/
            if (cs == clist.end()) {
                c.dest = IPAddress(IP_ADDRESS_ANY);
                c.destport = PORT_ANY;
                cerr << "Not listening for: " << c << endl << endl;
            }

            if ((*cs).connection.dest == IPAddress(IP_ADDRESS_ANY) || (*cs).connection.destport == PORT_ANY) {
                (*cs).connection.dest = c.dest;
                (*cs).connection.destport = c.destport;
            }

            cerr << (*cs).state.GetState() << endl;

            if (cs!=clist.end()) {
                switch ((*cs).state.GetState()) {

                  /* Listen*/   
                  /* As server, the first state, listen the connection request from the client*/
                  case LISTEN:
	          {

		      /*initialize*/
		     (*cs).state.SetLastSent(0);
		     (*cs).state.SetLastRecvd(0);
		     (*cs).state.SetLastAcked(0);
                     (*cs).state.SetSendRwnd(winsize);
		     //tcph.GetWinSize(winsizer);
                     tcph.GetFlags(oldflags);

                      /* ACK: if ACK bit is set, this field contains the value of the next sequence number */
                     
                      /* SYN = 1, ACK = 0  or reset, receive the connection request*/
		      
                      if ((IS_SYN(oldflags) && !IS_ACK(oldflags)) || IS_RST(oldflags)) {
                            cerr << "PASSIVE OPEN" << endl;
                            SET_SYN(flags);
                            SET_ACK(flags);
			
			    Packet sendPkt = createPacket(*cs, idr, flagsr, "", 0);
                            MinetSend(mux, sendPkt);

			    (*cs).state.SetLastSent((*cs).state.GetLastSent()+1); //shifted last_sent one byte to the right 
                      }

		       cerr << "LISTEN................"<< endl;
                      break;
		  }


                  /* SYN received */
                  /* As server, the second state, if IS_ACK = 1, set state to established
                                                  if IS_ACK = 0, means the ack which the server sent has lost, 
                                                  the client send the send connection request
                  */
                  case SYN_RCVD:
                      if (IS_ACK(oldflags) && !IS_PSH(oldflags)) {
                          cerr << "PASSIVE OPEN ACK" << endl;

                          /*change state to establised*/
                          (*cs).state.SetState(ESTABLISHED);

                      } else if ((IS_SYN(oldflags) && !IS_ACK(oldflags)) || IS_RST(oldflags)) {
                          /* synack is lost */
                          cerr << "SYNACK DROPPED" << endl;

                          /* this time we don't change the state, the state is still set to SYN_RCVD*/
                          (*cs).state.SetLastSent(seqnum);
                          (*cs).state.SetSendRwnd(winsize);
                          SET_SYN(flags);
                          SET_ACK(flags);

                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      }
                      break;


                  /* Send AYN */
                  /* As client, SYN = 1, ACK = 1 , collection established*/
                  case SYN_SENT:
                      if (IS_SYN(oldflags) && IS_ACK(oldflags)) {
                          cout << "ACTIVE OPEN ACK" << endl;

                          /*change state to establised*/
                          (*cs).state.SetState(ESTABLISHED);
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          SockRequestResponse write(WRITE,
                                              (*cs).connection,
                                              data,
                                              0,
                                              EOK);  /* EOK, no error */

                           MinetSend(sock, write);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      } else if (IS_SYN(oldflags)) {

                        /* same to LISTEN */
                          cerr << "PASSIVE OPEN" << endl;
                          (*cs).state.SetState(SYN_RCVD);
                          (*cs).state.SetLastSent(seqnum);
                          (*cs).state.SetSendRwnd(winsize);
                          SET_SYN(flags);
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      }
                     break;


                   case ESTABLISHED:

                      /* If receive the close request */
                      if (IS_FIN(oldflags)) {
                          cerr << endl << "FOUND FIN!" << endl;

                          /* set state to CLOST_WAIT*/
                          (*cs).state.SetState(CLOSE_WAIT);
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          SockRequestResponse close(CLOSE,
                                                  (*cs).connection,
                                                  data,
                                                  hlenr,
                                                  EOK); 
                          MinetSend(sock, close);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      }else if (IS_RST(oldflags)) {

                          /* Do we need to change state ? Change to listen as the protocol? */
                          cerr << endl << "RESET CONN!" << endl;
                          (*cs).state.SetLastSent(seqnum);
                          (*cs).state.SetSendRwnd(winsize);
                          SET_SYN(flags);
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      } else {

                          /* Received the packet */
                          cerr << "GOT DATA PACKET!" << endl;
                          unsigned short templen = 0;
                          unsigned short &templenr = templen;
                          unsigned char iplen = 0;
                          unsigned char &iplen_ref = iplen;
                          ipl.GetTotalLength(templenr);

			 /*get ip header length, do not multiple 4 */
                          ipl.GetHeaderLength(iplen_ref); 

                          /* len is stored as words, 4 bytes */
                          /* tcphlen : length of tcp header, have multiple 4*/
                          /* temphlen :  header length of ip header */
                          templen -= 4 * iplen_ref + tcphlen;  

                          /* virtual Buffer & ExtractFront (size_t size) extract content from buffer*/
                          data = p.GetPayload().ExtractFront(templen);
                          cerr << endl << data << endl << endl;
                          SockRequestResponse write(WRITE,
                                                  (*cs).connection,
                                                  data,
                                                  templen,
                                                  EOK);

                          /* send data to application layer*/
                          MinetSend(sock, write);

                          /* add sent packet to queue , buffer the data for the applicatoin layer*/
                          SocksPending.push(write);

                          /* Do we need to store the the packet we send to the */
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + templen, winsizer, hlenr, uptrr, flagsr, "This is the response of the received package", 0);
                          cerr << newp << endl << endl << acknum << endl << templen << endl;
                          (*cs).state.SetLastRecvd(acknumr + templen);
                          MinetSend(mux, newp);
                      }
                      break;

                  case FIN_WAIT1:
		  {
                      if (IS_FIN(oldflags)) { // simultaneous close
                          cerr << endl << "FOUND FIN!" << endl;
                          (*cs).state.SetState(TIME_WAIT);
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      } else if (IS_ACK(oldflags) && !IS_PSH(oldflags)) {
                            cerr << endl << "FOUND CLOSE ACK" << endl;
                            (*cs).state.SetState(FIN_WAIT2);
                            (*cs).state.SetLastRecvd(acknumr + 1);
                      }
                      break;

		 }
                  case FIN_WAIT2:
		  {
                      if (IS_FIN(oldflags)) {
                          cerr << endl << "GOT FIN" << endl;
                          (*cs).state.SetState(TIME_WAIT);
                          SET_ACK(flags);
                          Packet newp = MakeTCPPacket(c, idr, seqnumr, acknumr + 1, winsizer, hlenr, uptrr, flagsr, "", 0);
                          MinetSend(mux, newp);
                          (*cs).state.SetLastRecvd(acknumr + 1);
                      }
                      break;
		  }

                  case LAST_ACK:
                      if (IS_ACK(oldflags)) {
                           clist.erase(cs);
                      }
                      break;
                }
            }
        }


        //  Data from the Sockets layer above  //
        if (event.handle==sock) {

	    SockRequestResponse s;
	    MinetReceive(sock,s);
	    cerr << "Received Socket Request:" << s << endl;
            ConnectionList<TCPState>::iterator cs = clist.FindMatching(s.connection);
            ConnectionToStateMapping<TCPState> m;


            if (cs == clist.end()) {
                m.connection = s.connection;
                m.state.SetState(CLOSED);
                clist.push_back(m);
                cerr << m << endl << endl;
                cs = clist.FindMatching(s.connection);
            }


            Packet newp;
            unsigned int len = 0;
            unsigned int sending = 0;
            char *datachars = NULL;


            switch (s.type) {
                  case CONNECT: 
		  {
                    cerr << "ACTIVE OPEN INIT!" << endl << endl;
                    seqnum = rand() % 50000;
                    (*cs).state.SetState(SYN_SENT);
                    SET_SYN(flags);
                    newp = MakeTCPPacket(s.connection, idr, seqnumr, acknumr, winsizer, hlenr, uptrr, flagsr, "", 0);
                    MinetSend(mux, newp);
                    SockRequestResponse res(STATUS,
                    (*cs).connection,
                    data,
                    0,
                    EOK);
                    MinetSend(sock, res);
                    (*cs).state.SetLastSent(seqnum);
                    (*cs).state.SetLastRecvd(acknum);
                  
                    break;
		 }

                 case ACCEPT:
		 {
		    cerr << "PASSIVE OPEN INIT!" << endl << endl;
		    (*cs).state.SetState(LISTEN);
		    cerr << m << endl << endl;                   
		    break;
		}
            }

        }
    }
  }
  return 0;
}


void packetMaker(Packet &packet, ConnectionToStateMapping<TCPState>& constate, int size_of_data, int whichFlag)
{
    unsigned char flags = 0;
    int packet_length = size_of_data + TCP_HEADER_BASE_LENGTH + IP_HEADER_BASE_LENGTH;
    IPHeader ip;
    TCPHeader tcp;
    IPAddress source = constate.connection.src;
    IPAddress destination = constate.connection.dest;
    //create the IP packet with source, destination, length, and protocol
    ip.SetSourceIP(source);
    ip.SetDestIP(destination);
    ip.SetTotalLength(packet_length);
    ip.SetProtocol(IP_PROTO_TCP);
    packet.PushFrontHeader(ip);
    switch (whichFlag){
        case S_SYN_ACK:
            SET_SYN(flags);
            SET_ACK(flags);
            break;
        case S_RST:
            SET_RST(flags);
            break;
        case S_ACK:
            SET_ACK(flags);
            break;
        case S_FIN:
            SET_FIN(flags);
            break;
        case S_SYN:
            SET_SYN(flags);
            break;
        default:
        break;
    }
    //just followed all the tcp.h stuff top to bottom
    tcp.SetSourcePort(constate.connection.srcport, packet);
    tcp.SetDestPort(constate.connection.destport, packet);
    tcp.SetHeaderLen(TCP_HEADER_BASE_LENGTH, packet);
    tcp.SetFlags(0, packet);
    tcp.SetAckNum(constate.state.GetLastRecvd(), packet);
    tcp.SetSeqNum(constate.state.GetLastAcked()+1, packet);
    tcp.SetWinSize(constate.state.GetN(), packet); //window size 
    tcp.SetUrgentPtr(0, packet);
    tcp.RecomputeChecksum(packet);
    packet.PushBackHeader(tcp);
}



Packet createPacket(ConnectionToStateMapping<TCPState>& constate, const unsigned int &id,const unsigned char &flags, const char *data, const size_t datalen) {
    Packet p(data, datalen);
    // Packet p;
    IPHeader ipheader;
    TCPHeader tcpheader;
    Connection c = constate.connection;
    ipheader.SetProtocol(IP_PROTO_TCP);
    ipheader.SetSourceIP(c.src);
    ipheader.SetDestIP(c.dest);
    ipheader.SetTotalLength(TCP_HEADER_BASE_LENGTH + IP_HEADER_BASE_LENGTH);
    ipheader.SetID(id);
    p.PushFrontHeader(ipheader);
    tcpheader.SetDestPort(c.destport, p);
    tcpheader.SetSourcePort(c.srcport, p);

//    tcpheader.SetSeqNum(seqnum, p);
//   tcpheader.SetAckNum(acknum, p);
    tcpheader.SetAckNum(constate.state.GetLastRecvd(), p);
    tcpheader.SetSeqNum(constate.state.GetLastAcked()+1, p);

    tcpheader.SetWinSize(constate.state.GetN(), p);
    tcpheader.SetHeaderLen(TCP_HEADER_BASE_LENGTH, p);
    tcpheader.SetUrgentPtr(0, p);
    tcpheader.SetFlags(flags, p);
    p.PushBackHeader(tcpheader);
    cerr << ipheader << endl;
    cerr << tcpheader << endl;
    return p;
}




Packet MakeTCPPacket(const Connection c, const unsigned int &id, const unsigned int &seqnum, const unsigned int &acknum, const unsigned short &winsize, const unsigned char &hlen, const unsigned short &urgptr, const unsigned char &flags, const char *data, const size_t datalen) {
    Packet p(data, datalen);
    // Packet p;
    IPHeader ih;
    TCPHeader th;
    ih.SetProtocol(IP_PROTO_TCP);
    ih.SetSourceIP(c.src);
    ih.SetDestIP(c.dest);
    ih.SetTotalLength(TCP_HEADER_BASE_LENGTH + IP_HEADER_BASE_LENGTH);
    ih.SetID(id);
    p.PushFrontHeader(ih);
    th.SetDestPort(c.destport, p);
    th.SetSourcePort(c.srcport, p);
    th.SetSeqNum(seqnum, p);
    th.SetAckNum(acknum, p);
    th.SetWinSize(winsize, p);
    th.SetHeaderLen(hlen, p);
    th.SetUrgentPtr(urgptr, p);
    th.SetFlags(flags, p);
    p.PushBackHeader(th);
    cerr << ih << endl;
    cerr << th << endl;
    return p;
}







int ConditionalMinetSend(const MinetHandle &handle, const Packet &object) {
    int send = rand() % 3;
    if (send != 1) {
    MinetSend(handle, object);
    } else
    cerr << endl << endl << "NOPEEEEEEEEE" << endl << endl;
    return 0;
}
